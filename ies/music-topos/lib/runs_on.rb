# lib/runs_on.rb
# Module Action: Pattern Runs On Matter
#
# The key insight from Libkind & Spivak (ACT 2024):
#
# Î_{p,q} : ğ”ªp âŠ— ğ” q â†’ ğ”ª(pâŠ—q)
#
# Musical interpretation:
# - Pattern (score) runs on Matter (performer/synth)
# - At each decision point, Matter provides a response
# - The wellfounded (finite) pattern consumes from non-wellfounded (infinite) matter

require_relative 'free_monad'
require_relative 'cofree_comonad'
require_relative 'score_event'
require_relative 'sonic_pi_renderer'

module RunsOn
  extend self
  
  # ============================================================================
  # THE MODULE ACTION
  # ============================================================================
  
  # Run a pattern on matter, producing score events
  # @param pattern [FreeMonad::Free] The musical pattern (decision tree)
  # @param matter [CofreeComonad::MusicalMatter] The musical environment
  # @return [Array<Hash>] Score events generated by running pattern on matter
  def runs_on(pattern, matter)
    events = []
    current_beat = matter.beat
    
    interpret(pattern, matter, current_beat, events)
    
    events
  end
  
  # ============================================================================
  # INSTRUCTION-MATTER PAIRING
  # ============================================================================
  
  # Pair an instruction with matter, producing result and continuations
  # Returns: [result, next_pattern, next_matter, events]
  def pair_instruction(instruction, matter, current_beat)
    events = []
    
    case instruction
    when FreeMonad::PlayNote
      # Matter provides audio output
      pitches = [instruction.pitch]
      
      # Execute on matter
      matter.play_fn.call(pitches, instruction.duration, instruction.amplitude)
      
      # Create event
      events << create_note_event(
        pitches, instruction.duration, instruction.amplitude, current_beat
      )
      
      new_beat = current_beat + instruction.duration
      next_pattern = instruction.next_fn.call
      next_matter = matter.advance(instruction.duration)
      
      [nil, next_pattern, next_matter, new_beat, events]
      
    when FreeMonad::PlayChord
      pitches = instruction.pitches
      
      matter.play_fn.call(pitches, instruction.duration, instruction.amplitude)
      
      events << create_note_event(
        pitches, instruction.duration, instruction.amplitude, current_beat
      )
      
      new_beat = current_beat + instruction.duration
      next_pattern = instruction.next_fn.call
      next_matter = matter.advance(instruction.duration)
      
      [nil, next_pattern, next_matter, new_beat, events]
      
    when FreeMonad::Rest
      events << {
        id: "rest-#{current_beat}",
        at: current_beat,
        dur: instruction.duration,
        world_object: { world: :rest_space, type: :rest },
        audio: nil
      }
      
      new_beat = current_beat + instruction.duration
      next_pattern = instruction.next_fn.call
      next_matter = matter.advance(instruction.duration)
      
      [nil, next_pattern, next_matter, new_beat, events]
      
    when FreeMonad::Transform
      # Matter provides transformation capability
      transform_fn = matter.transforms[instruction.transformation]
      result = transform_fn ? transform_fn.call(instruction.target) : instruction.target
      
      next_pattern = instruction.next_fn.call(result)
      
      [result, next_pattern, matter, current_beat, events]
      
    when FreeMonad::Branch
      # Matter provides condition evaluation
      condition_fn = matter.conditions[instruction.condition]
      result = condition_fn ? condition_fn.call(matter) : false
      
      next_pattern = result ? instruction.then_branch : instruction.else_branch
      
      [result, next_pattern, matter, current_beat, events]
      
    when FreeMonad::Sequence
      # Process each action in sequence
      [nil, instruction.actions, matter, current_beat, events]
      
    when FreeMonad::Parallel
      # Process all voices (they share the same starting beat)
      [nil, instruction.voices, matter, current_beat, events]
      
    else
      raise "Unknown instruction: #{instruction.class}"
    end
  end
  
  # ============================================================================
  # INTERPRETER
  # ============================================================================
  
  def interpret(pattern, matter, current_beat, events)
    # Pure patterns just return current beat (no-op)
    return current_beat if pattern.pure?
    
    instruction = pattern.instruction
    
    case instruction
    when FreeMonad::Sequence
      # Process each action sequentially
      beat = current_beat
      instruction.actions.each do |action|
        sub_events = []
        result_beat = interpret(action, matter, beat, sub_events)
        beat = result_beat if result_beat
        events.concat(sub_events)
        if beat && matter.beat
          matter = matter.advance(beat - matter.beat) if beat > matter.beat
        end
      end
      beat
      
    when FreeMonad::Parallel
      # Process all voices starting at same beat
      max_beat = current_beat
      instruction.voices.each do |voice|
        sub_events = []
        end_beat = interpret(voice, matter, current_beat, sub_events)
        events.concat(sub_events)
        max_beat = [max_beat, end_beat || current_beat].max
      end
      max_beat
      
    else
      # Single instruction
      _, next_pattern, next_matter, new_beat, new_events = 
        pair_instruction(instruction, matter, current_beat)
      
      events.concat(new_events)
      
      if next_pattern && next_pattern.respond_to?(:pure?) && !next_pattern.pure?
        interpret(next_pattern, next_matter, new_beat, events)
      else
        new_beat
      end
    end
  end
  
  # ============================================================================
  # HELPERS
  # ============================================================================
  
  def create_note_event(pitches, duration, amplitude, beat)
    {
      id: "note-#{beat}-#{pitches.hash}",
      at: beat,
      dur: duration,
      world_object: { world: :pitch_space, type: :note, value: pitches },
      audio: {
        frequencies: pitches.map { |p| midi_to_hz(p) },
        amplitude: amplitude,
        synth: 'sine'
      },
      meta: { section: :runs_on }
    }
  end
  
  def midi_to_hz(midi)
    440.0 * (2.0 ** ((midi - 69) / 12.0))
  end
  
  # ============================================================================
  # REAL-TIME RUNNER (Sonic Pi backend for Ruby)
  # ============================================================================
  
  # Run pattern on matter in real-time via Sonic Pi
  def run_realtime(pattern, matter, backend: :sonic_pi)
    start_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)
    events = runs_on(pattern, matter)
    
    # Initialize Sonic Pi renderer
    renderer = case backend
               when :sonic_pi
                 SonicPiRenderer.new(synth: :sine, use_osc: true)
               when :console
                 nil
               end
    
    puts "â–¶ Playing #{events.length} events via #{backend}..."
    
    events.each do |event|
      next unless event[:audio]  # Skip rests
      
      # Calculate target time
      target_seconds = event[:at] * 60.0 / matter.tempo
      now = Process.clock_gettime(Process::CLOCK_MONOTONIC) - start_time
      
      # Wait until target time
      sleep(target_seconds - now) if target_seconds > now
      
      # Play the event via Sonic Pi
      if renderer
        pitches = event[:world_object][:value] rescue [60]
        pitches = [pitches] unless pitches.is_a?(Array)
        duration = event[:dur] || 1.0
        
        pitches.each do |midi_note|
          renderer.send_osc_message('/trigger/prophet', midi_note.to_i, duration.to_f)
        end
      else
        puts "  #{event[:at].round(2)}s: #{event[:audio][:frequencies].map(&:round)} Hz"
      end
    end
    
    events
  end
  
  # ============================================================================
  # SONIC PI LIVE LOOP SETUP
  # ============================================================================
  
  SONIC_PI_LISTENER = <<~SONIC_PI
    # Paste this into Sonic Pi to receive OSC from Ruby
    live_loop :ruby_listener do
      use_real_time
      note, duration = sync "/osc*/trigger/prophet"
      synth :sine, note: note, sustain: duration, release: 0.1
    end
  SONIC_PI
  
  def print_sonic_pi_setup
    puts "=" * 60
    puts "SONIC PI SETUP"
    puts "=" * 60
    puts "Paste this code into Sonic Pi before running:"
    puts
    puts SONIC_PI_LISTENER
    puts "=" * 60
  end
  
  # ============================================================================
  # BATCH RENDERER
  # ============================================================================
  
  # Convert pattern to score events for batch rendering
  def to_score_events(pattern, matter)
    events = runs_on(pattern, matter)
    events.reject { |e| e[:audio].nil? }  # Remove rests for audio
  end
end

# ============================================================================
# EXAMPLE USAGE
# ============================================================================

if __FILE__ == $0
  puts "=== Pattern Runs On Matter Demo ==="
  puts
  
  # Build the pattern (Free monad)
  pattern = InitialWorldPattern.build
  
  # Create the matter (Cofree comonad environment)
  matter = CofreeComonad::MusicalMatter.new(
    tempo: 120,
    timbre: :sine,
    volume: 0.5
  )
  
  # Run pattern on matter
  puts "Running Initial World pattern on matter..."
  events = RunsOn.runs_on(pattern, matter)
  
  puts "\nGenerated #{events.length} events:"
  events.first(10).each do |e|
    if e[:audio]
      freqs = e[:audio][:frequencies].map { |f| f.round(1) }
      puts "  Beat #{e[:at].round(2)}: #{freqs} Hz (#{e[:dur]} beats)"
    else
      puts "  Beat #{e[:at].round(2)}: REST (#{e[:dur]} beats)"
    end
  end
  puts "  ..." if events.length > 10
end
