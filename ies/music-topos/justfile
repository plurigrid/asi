# Music Topos Justfile
# Single command to setup and run: `just world`

set shell := ["bash", "-c"]
set dotenv-load := false

# Default recipe
default:
    @just --list

# Setup SuperCollider startup configuration
setup-supercollider:
    #!/bin/bash
    set -e

    SC_DIR="$HOME/Library/Application Support/SuperCollider"
    SC_STARTUP="$SC_DIR/startup.scd"

    echo "ðŸ“ Ensuring SuperCollider config directory exists..."
    mkdir -p "$SC_DIR"

    echo "ðŸ“ Installing startup.scd..."
    cp startup.scd "$SC_STARTUP"
    chmod 644 "$SC_STARTUP"

    echo "âœ“ SuperCollider startup configuration installed"
    echo "  Location: $SC_STARTUP"
    ls -lh "$SC_STARTUP"

# Check if SuperCollider server is running
check-sc-server:
    #!/bin/bash
    if lsof -i :57110 > /dev/null 2>&1; then
        echo "âœ“ SuperCollider server is running on port 57110"
        return 0
    else
        echo "âœ— SuperCollider server is NOT running on port 57110"
        return 1
    fi

# Boot SuperCollider server (requires SuperCollider.app to be installed)
boot-sc-server:
    #!/bin/bash
    set -e

    echo "ðŸŽµ Booting SuperCollider server..."

    SC_APP="/Applications/SuperCollider.app"
    SCLANG="$SC_APP/Contents/MacOS/sclang"
    SCSYNTH="$SC_APP/Contents/Resources/scsynth"

    # Check if SuperCollider is installed
    if [ ! -f "$SCSYNTH" ]; then
        echo "âœ— SuperCollider not found at $SCSYNTH"
        echo ""
        echo "Please install SuperCollider:"
        echo "  1. Download from https://supercollider.github.io/downloads.html"
        echo "  2. Install to /Applications/SuperCollider.app"
        echo "  3. Run this justfile again"
        exit 1
    fi

    # Boot using sclang with boot script (more reliable than direct scsynth)
    # The boot script will define the sine synth and keep the server running
    if [ -f "$SCLANG" ]; then
        echo "Starting SuperCollider server via sclang (will load/define synths)..."

        # Run the boot script with sclang
        # Use nohup and redirect output to prevent sclang from hanging
        nohup "$SCLANG" boot-server.scd > /tmp/sc_boot.log 2>&1 &
        SC_PID=$!

        echo "SuperCollider booting (PID: $SC_PID)..."
        sleep 6  # Give sclang time to boot server and define synths
    else
        echo "Error: sclang not found at $SCLANG"
        exit 1
    fi

    # Verify it's running
    if lsof -i :57110 > /dev/null 2>&1; then
        echo "âœ“ SuperCollider server booted successfully"
        echo "  Server PID: $SC_PID"
        echo "  To stop: killall sclang; killall scsynth"
    else
        echo "âœ— Failed to boot SuperCollider server"
        exit 1
    fi

# Verify dependencies are installed
check-deps:
    #!/bin/bash
    set -e

    echo "ðŸ” Checking dependencies..."

    # Check Clojure/Leiningen via Flox
    if ! which flox > /dev/null 2>&1; then
        echo "âœ— flox not found. Install from: https://flox.dev"
        exit 1
    fi
    echo "âœ“ flox available"

    # Check if leiningen works via flox
    if ! flox activate -- lein --version > /dev/null 2>&1; then
        echo "âœ— leiningen not available in flox environment"
        exit 1
    fi
    echo "âœ“ leiningen available"

    # Check SuperCollider
    SC_SYNTH="/Applications/SuperCollider.app/Contents/Resources/scsynth"
    if [ ! -f "$SC_SYNTH" ]; then
        echo "âœ— scsynth not found at $SC_SYNTH"
        echo "Install SuperCollider from: https://supercollider.github.io/downloads.html"
        exit 1
    fi
    echo "âœ“ scsynth available at $SC_SYNTH"

    echo ""
    echo "âœ“ All dependencies present"

# Build the Clojure project
build:
    #!/bin/bash
    set -e

    echo "ðŸ”¨ Building Music Topos..."
    flox activate -- lein uberjar 2>&1 | tail -20

    if [ -f "target/music-topos-0.1.0-standalone.jar" ]; then
        echo "âœ“ Build successful"
        ls -lh target/music-topos-0.1.0-standalone.jar
    else
        echo "âœ— Build failed"
        exit 1
    fi

# Run InitialObjectWorld
run-initial:
    #!/bin/bash
    set -e

    echo ""
    echo "ðŸŽµ Running InitialObjectWorld..."
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""

    flox activate -- lein run initial

# Run TerminalObjectWorld
run-terminal:
    #!/bin/bash
    set -e

    echo ""
    echo "ðŸŽ¼ Running TerminalObjectWorld..."
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""

    flox activate -- lein run terminal

# Show system audio configuration (macOS)
check-audio:
    #!/bin/bash

    echo "ðŸ”Š Checking system audio configuration..."
    echo ""

    if [[ "$OSTYPE" == "darwin"* ]]; then
        echo "ðŸ“± Output Devices:"
        audiodevicelist 2>/dev/null | grep -i "Built-in Output" || \
            system_profiler SPAudioDataType 2>/dev/null | head -20 || \
            echo "  (Use System Preferences â†’ Sound to configure)"

        echo ""
        echo "ðŸ”‰ Current Volume:"
        osascript -e 'output volume of (get volume settings)' 2>/dev/null || echo "  (Use System Preferences to adjust)"
    else
        echo "âš ï¸  Audio checking only implemented for macOS"
        echo "Please verify audio output in your system settings"
    fi

# Kill any running SuperCollider processes
stop-sc:
    #!/bin/bash

    echo "Stopping SuperCollider servers..."
    killall scsynth 2>/dev/null || echo "No scsynth processes running"
    killall sclang 2>/dev/null || echo "No sclang processes running"

    sleep 1
    echo "âœ“ SuperCollider stopped"

# Show logs from last run
logs:
    #!/bin/bash

    if [ -f ".music-topos-run.log" ]; then
        cat .music-topos-run.log
    else
        echo "No log file found. Run 'just world' first."
    fi

# Complete setup and execution pipeline
world:
    #!/bin/bash
    set -e

    clear

    echo "ðŸŒ Music Topos - Complete World Setup"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""

    # Step 1: Check dependencies
    echo "Step 1/7: Checking dependencies..."
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    just check-deps
    echo ""

    # Step 2: Setup SuperCollider configuration (BEFORE booting!)
    echo "Step 2/7: Setting up SuperCollider..."
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    just setup-supercollider
    echo ""

    # Stop any existing SuperCollider server to ensure clean boot with startup.scd
    echo "Stopping any existing SuperCollider servers..."
    killall scsynth 2>/dev/null || true
    sleep 2

    # Step 3: Check if SC is running, boot if needed
    echo "Step 3/7: Booting SuperCollider server..."
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    just boot-sc-server
    echo ""

    # Step 4: Build project
    echo "Step 4/7: Building Clojure project..."
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    just build
    echo ""

    # Step 5: Check audio
    echo "Step 5/7: Checking audio configuration..."
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    just check-audio
    echo ""

    # Step 6: Run InitialObjectWorld
    echo "Step 6/7: Playing InitialObjectWorld..."
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    just run-initial 2>&1 | tee -a .music-topos-run.log
    echo ""

    # Step 7: Run TerminalObjectWorld
    echo "Step 7/7: Playing TerminalObjectWorld..."
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    just run-terminal 2>&1 | tee -a .music-topos-run.log
    echo ""

    # Final summary
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "âœ“ Music Topos World Complete!"
    echo ""
    echo "What you should have heard:"
    echo "  â€¢ InitialObjectWorld: Initial pitch â†’ all pitches â†’ harmonic functions â†’ modulation"
    echo "  â€¢ TerminalObjectWorld: Exposition â†’ development â†’ recapitulation â†’ coda"
    echo ""
    echo "If no sound was heard:"
    echo "  1. Check system audio output is enabled"
    echo "  2. Check speakers/headphones are connected"
    echo "  3. Run: just check-audio"
    echo "  4. Check SuperCollider startup.scd loaded:"
    echo "       ls ~/Library/Application\ Support/SuperCollider/startup.scd"
    echo ""
    echo "To run individual worlds later:"
    echo "  just run-initial    # Play InitialObjectWorld"
    echo "  just run-terminal   # Play TerminalObjectWorld"
    echo ""
    echo "To stop SuperCollider:"
    echo "  just stop-sc"
    echo ""

# Play curriculum in realtime via SuperCollider
curriculum-realtime world="initial":
    ruby bin/play_curriculum.rb --mode realtime --world {{world}}

# Render curriculum to WAV file  
curriculum-wav world="initial":
    ruby bin/play_curriculum.rb --mode batch --world {{world}}
    afplay /tmp/curriculum.wav

# Pattern Runs On Matter (Free Monad / Cofree Comonad architecture)
# Based on Libkind & Spivak "Pattern Runs on Matter" (ACT 2024)
pattern-realtime world="initial" tempo="90":
    ruby bin/pattern_runs_on_matter.rb --mode realtime --world {{world}} --tempo {{tempo}} --verbose

pattern-wav world="initial" tempo="90":
    ruby bin/pattern_runs_on_matter.rb --mode batch --world {{world}} --tempo {{tempo}} --output /tmp/pattern.wav

# Full curriculum walkthrough using categorical semantics
topos-walkthrough:
    @echo "ðŸŽµ Walking through the Topos of Music"
    @echo "   Pattern (Free Monad) runs on Matter (Cofree Comonad)"
    @echo ""
    ruby bin/pattern_runs_on_matter.rb --mode batch --world full --tempo 100

# Virtuoso showcase: Daniel Avery, Loraine James, Machine Girl, Mica Levi, Quantum Guitar, CJ Carr
virtuoso:
    @echo "ðŸŽµ VIRTUOSO SHOWCASE"
    @echo "   Daniel Avery Ã— Loraine James Ã— Machine Girl Ã— Mica Levi Ã— Quantum Guitar Ã— CJ Carr"
    @echo ""
    ruby bin/pattern_runs_on_matter.rb --mode batch --world virtuoso --tempo 85 --output /tmp/virtuoso.wav

# Individual artist styles
avery:
    ruby bin/pattern_runs_on_matter.rb --mode batch --world virtuoso --tempo 75 --output /tmp/avery.wav

# Dark industrial (Mica Levi / Xenakis mode)  
dark:
    ruby bin/pattern_runs_on_matter.rb --mode batch --world full --tempo 60 --output /tmp/dark.wav

# ============================================================================
# QUANTUM APHEX TWIN & AUTECHRE
# Free Monad patterns: polyrhythm, Markov chains, cellular automata
# ============================================================================

# Aphex Twin showcase: drill 'n' bass, ambient drift, prepared piano, equation melody
aphex:
    @echo "ðŸŽµ QUANTUM APHEX TWIN"
    @echo "   Drill 'n' Bass Ã— Ambient Drift Ã— Prepared Piano Ã— Equation Melody"
    @echo ""
    ruby bin/pattern_runs_on_matter.rb --mode batch --world aphex --tempo 140 --output /tmp/aphex.wav

# Autechre showcase: generative rhythm, cellular automata, spectral morph, anti-groove
autechre:
    @echo "ðŸŽµ QUANTUM AUTECHRE"
    @echo "   Generative Rhythm Ã— Cellular Automata Ã— Spectral Morph Ã— Anti-Groove"
    @echo ""
    ruby bin/pattern_runs_on_matter.rb --mode batch --world autechre --tempo 100 --output /tmp/autechre.wav

# Full quantum electronic showcase (Aphex + Autechre + collision)
quantum-electronic:
    @echo "ðŸŽµ QUANTUM ELECTRONIC SHOWCASE"
    @echo "   Aphex Twin Ã— Autechre Ã— Category Theory"
    @echo ""
    ruby bin/pattern_runs_on_matter.rb --mode batch --world quantum-electronic --tempo 120 --output /tmp/quantum-electronic.wav

# Individual Aphex patterns
aphex-drill:
    ruby bin/pattern_runs_on_matter.rb --mode batch --world aphex --tempo 160 --output /tmp/aphex-drill.wav

aphex-ambient:
    ruby bin/pattern_runs_on_matter.rb --mode batch --world aphex --tempo 60 --output /tmp/aphex-ambient.wav

# Individual Autechre patterns  
autechre-generative:
    ruby bin/pattern_runs_on_matter.rb --mode batch --world autechre --tempo 90 --output /tmp/autechre-gen.wav

autechre-cellular:
    ruby bin/pattern_runs_on_matter.rb --mode batch --world autechre --tempo 80 --output /tmp/autechre-ca.wav

# ============================================================================
# MAXIMUM DYNAMISM
# Every degree of freedom derangeable with entropy
# ============================================================================

# Maximum dynamism demo (subtle â†’ moderate â†’ chaotic â†’ maximum)
max-dynamism:
    @echo "ðŸŽ² MAXIMUM DYNAMISM"
    @echo "   Every DOF derangeable with entropy"
    @echo ""
    ruby bin/pattern_runs_on_matter.rb --mode batch --world max-dynamism --tempo 120 --output /tmp/max-dynamism.wav

# Maximum dynamism Aphex Twin (drill 'n' bass with full chaos)
max-aphex:
    @echo "ðŸŽ² MAXIMUM APHEX TWIN"
    @echo "   Levy flights Ã— Chaotic durations Ã— Structural derangement"
    @echo ""
    ruby bin/pattern_runs_on_matter.rb --mode batch --world max-aphex --tempo 150 --output /tmp/max-aphex.wav

# Maximum dynamism Autechre (generative with brownian pitch, irrational time)
max-autechre:
    @echo "ðŸŽ² MAXIMUM AUTECHRE"
    @echo "   Brownian pitch Ã— Chaotic duration Ã— Self-modifying meta"
    @echo ""
    ruby bin/pattern_runs_on_matter.rb --mode batch --world max-autechre --tempo 95 --output /tmp/max-autechre.wav

# Chaos comparison: same pattern with increasing entropy
chaos-spectrum:
    @echo "ðŸŽ² CHAOS SPECTRUM: Subtle â†’ Moderate â†’ Chaotic â†’ Maximum"
    @echo ""
    ruby -Ilib -e "require 'maximum_dynamism'; [:subtle, :moderate, :chaotic, :maximum].each { |l| puts \"=== #{l} ===\"; puts MaximumDynamism::DerangementConfig.send(l).pitch.intensity }"

# ============================================================================
# INDUSTRIAL JUNGLE SELF-INVOLUTION
# Î¹: UIState â†’ UIState | Î¹âˆ˜Î¹ â†’ id (fixed point)
# Non-standard tempo, breakbeat chaos, half-time bass
# ============================================================================

# Full jungle involution showcase (3 phases of evolution)
jungle:
    @echo "ðŸ¥ INDUSTRIAL JUNGLE SELF-INVOLUTION"
    @echo "   Î¹: UIState â†’ UIState | Trifurcate â†’ Evaluate â†’ Argmax"
    @echo "   Tempo: 172 BPM with drift | Breakbeat + Reese Bass"
    @echo ""
    ruby bin/pattern_runs_on_matter.rb --mode batch --world jungle --tempo 172 --output /tmp/jungle.wav

# Quick jungle (single evolution pass)
jungle-quick:
    @echo "ðŸ¥ QUICK JUNGLE"
    @echo ""
    ruby bin/pattern_runs_on_matter.rb --mode batch --world jungle-quick --tempo 172 --output /tmp/jungle-quick.wav

# Jungle at different tempos
jungle-slow:
    ruby bin/pattern_runs_on_matter.rb --mode batch --world jungle-quick --tempo 140 --output /tmp/jungle-slow.wav

jungle-fast:
    ruby bin/pattern_runs_on_matter.rb --mode batch --world jungle-quick --tempo 185 --output /tmp/jungle-fast.wav

# ============================================================================
# GAY.JL NEVERENDING PRODUCTIONS
# Color transitions guide infinite music
# Ï†: Î³=2â¶â´/Ï† â†’ hue+=137.508Â° â†’ spiral forever â†’ never repeat â†’ always return
# ============================================================================

# Full neverending showcase (all styles)
neverending:
    @echo "ðŸŒˆ NEVERENDING PRODUCTIONS"
    @echo "   Gay.jl Color Transitions â†’ Infinite Music"
    @echo "   Ï†: hue += 137.508Â° per step"
    @echo ""
    ruby bin/pattern_runs_on_matter.rb --mode batch --world neverending --tempo 90 --output /tmp/neverending.wav

# Individual color-guided styles
gay-drone:
    @echo "ðŸŒˆ GAY DRONE (64 beats)"
    ruby bin/pattern_runs_on_matter.rb --mode batch --world gay-drone --tempo 40 --output /tmp/gay-drone.wav

gay-ambient:
    @echo "ðŸŒˆ GAY AMBIENT (48 beats)"
    ruby bin/pattern_runs_on_matter.rb --mode batch --world gay-ambient --tempo 60 --output /tmp/gay-ambient.wav

gay-idm:
    @echo "ðŸŒˆ GAY IDM (32 beats)"
    ruby bin/pattern_runs_on_matter.rb --mode batch --world gay-idm --tempo 145 --output /tmp/gay-idm.wav

gay-jungle:
    @echo "ðŸŒˆ GAY JUNGLE (24 beats)"
    ruby bin/pattern_runs_on_matter.rb --mode batch --world gay-jungle --tempo 172 --output /tmp/gay-jungle.wav

gay-industrial:
    @echo "ðŸŒˆ GAY INDUSTRIAL (32 beats)"
    ruby bin/pattern_runs_on_matter.rb --mode batch --world gay-industrial --tempo 130 --output /tmp/gay-industrial.wav

# Print color guide (no audio, just show mappings)
color-guide:
    @ruby -Ilib -e "require 'gay_neverending'; GayNeverending::Showcase.print_color_guide(n: 30, seed: 42)"

# ============================================================================
# ONEOHTRIX POINT NEVER TRANSCENDENTAL PATTERNS
# 17-component parallel architecture for hyperreal electronic music
# ============================================================================

# Full transcendental piece (all 17 components layered)
opn-transcendental:
    @echo "ðŸŒŒ OPN TRANSCENDENTAL"
    @echo "   17 parallel components: Granular + Drone + Harmony + Glitch + Spectral..."
    @echo ""
    ruby bin/pattern_runs_on_matter.rb --mode batch --world opn-transcendental --tempo 72 --output /tmp/opn-transcendental.wav

# Garden of Delete style (uncanny MIDI orchestra + vocoder + glitch)
opn-garden:
    @echo "ðŸŒŒ OPN: GARDEN OF DELETE"
    ruby bin/pattern_runs_on_matter.rb --mode batch --world opn-garden --tempo 85 --output /tmp/opn-garden.wav

# R Plus Seven style (granular + MIDI orchestration + collage)
opn-rplus7:
    @echo "ðŸŒŒ OPN: R PLUS SEVEN"
    ruby bin/pattern_runs_on_matter.rb --mode batch --world opn-rplus7 --tempo 60 --output /tmp/opn-rplus7.wav

# Age Of style (vocal + polyrhythm + eccojam)
opn-ageof:
    @echo "ðŸŒŒ OPN: AGE OF"
    ruby bin/pattern_runs_on_matter.rb --mode batch --world opn-ageof --tempo 90 --output /tmp/opn-ageof.wav

# List all OPN components
opn-components:
    @echo "OPN Transcendental Components (17):"
    @ls -1 lib/opn/*.rb | xargs -I{} basename {} .rb | sort

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SYNERGISTIC 3-TUPLES: Skill Loading with GF(3) Conservation
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Synergistic triads demo
synergistic-triads:
    ruby -I lib lib/synergistic_triads.rb

# List all valid GF(3) triads
triads-list:
    ruby -I lib -e "require 'synergistic_triads'; SynergisticTriads.find_all_valid_triads.first(20).each { |t| puts t }"

# Find triads containing a specific skill
triads-for skill:
    ruby -I lib -e "require 'synergistic_triads'; SynergisticTriads.triads_for_skill('{{skill}}').each { |t| puts t }"

# Subagent determination for a task domain
subagent-for domain:
    ruby -I lib -e "require 'synergistic_triads'; d = SynergisticTriads::SubagentDeterminer.new; pp d.execute_with_triad(:{{domain}})"

# Find replacement skills (same trit, can substitute in triads)
replacements-for skill:
    ruby -I lib -e "require 'synergistic_triads'; SynergisticTriads.replacements_for('{{skill}}').each { |r| puts \"  #{r[:skill]} (#{r[:domain]})\" }"

# Immediate skill loading with colored output
load-triad domain:
    ruby -I lib -e "require 'synergistic_triads'; SynergisticTriads.load_triad_for_task(:{{domain}})"

# Show colored triad
colored-triad s1 s2 s3:
    ruby -I lib -e "require 'synergistic_triads'; pp SynergisticTriads.colored_triad(%w[{{s1}} {{s2}} {{s3}}])"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ACSET HISTORY: DuckDB queries on Claude history with GF(3) trits
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Query acset history from Claude history.jsonl
acset-history:
    duckdb -c ".read db/acset_history_view.sql" -c "SELECT id, SUBSTRING(display, 1, 100) as display, trit, gf3_sum FROM acset_history ORDER BY id DESC LIMIT 20"

# Query GeoACSet entries specifically
acset-geo:
    duckdb -c ".read db/acset_history_view.sql" -c "SELECT id, SUBSTRING(display, 1, 80), trit FROM acset_history WHERE LOWER(display) LIKE '%geoacset%'"

# Show trit distribution summary
acset-trit-summary:
    duckdb -c ".read db/acset_history_view.sql" -c "SELECT * FROM acset_trit_summary"

# Query acset history with custom pattern
acset-query pattern:
    duckdb -c ".read db/acset_history_view.sql" -c "SELECT id, SUBSTRING(display, 1, 100), trit FROM acset_history WHERE LOWER(display) LIKE '%{{pattern}}%' LIMIT 20"

# Show GeoACSet pattern entries
acset-patterns:
    duckdb -c ".read db/acset_history_view.sql" -c "SELECT id, acset_type, trit, SUBSTRING(display, 1, 80) FROM geoacset_patterns ORDER BY id"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DISCOHY THREAD OPERAD: Thread trees as rooted color operads
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Run DiscoHy thread operad demo
discohy-operad:
    hy lib/discohy_thread_operad.hy

# Initialize thread operad database
discohy-init-db:
    duckdb thread_operad.duckdb -c ".read db/thread_operad_schema.sql"
    @echo "âœ“ Thread operad database initialized"

# Query thread tree structure
discohy-tree:
    duckdb thread_operad.duckdb -c "SELECT * FROM thread_tree ORDER BY depth, path"

# Check GF(3) conservation across thread triplets
discohy-gf3:
    duckdb thread_operad.duckdb -c "SELECT * FROM gf3_sibling_triplets"

# Show GF(3) conservation summary
discohy-gf3-summary:
    duckdb thread_operad.duckdb -c "SELECT * FROM gf3_conservation_summary"

# Query operad variants
discohy-variants:
    duckdb thread_operad.duckdb -c "SELECT name, description, is_active, trit FROM operad_variants"

# Set active operad variant
discohy-set-variant variant:
    duckdb thread_operad.duckdb -c "UPDATE operad_variants SET is_active = FALSE; UPDATE operad_variants SET is_active = TRUE WHERE name = '{{variant}}';"
    @echo "âœ“ Active variant set to: {{variant}}"

# Show DisCoPy box representation
discohy-boxes:
    duckdb thread_operad.duckdb -c "SELECT box_id, box_name, domain, codomain_count, color_hex, color_trit FROM discopy_boxes"

# Show DisCoPy wire representation
discohy-wires:
    duckdb thread_operad.duckdb -c "SELECT source, target, wire_label, wire_trit FROM discopy_wires"

# Query thread colors (all 3 streams)
discohy-colors thread_id:
    duckdb thread_operad.duckdb -c "SELECT thread_id, live_h as 'LIVE HÂ°', verify_h as 'VERIFY HÂ°', backfill_h as 'BACKFILL HÂ°', trit FROM thread_nodes WHERE thread_id LIKE '%{{thread_id}}%'"

# Trit distribution by depth
discohy-trit-depth:
    duckdb thread_operad.duckdb -c "SELECT * FROM trit_by_depth"

# Operad arity distribution
discohy-arity:
    duckdb thread_operad.duckdb -c "SELECT * FROM operad_arity_distribution"

# Show color stream history for a thread (operad view)
discohy-stream-history thread_id:
    duckdb thread_operad.duckdb -c "SELECT stream, index_position, h as hue, trit, timestamp FROM color_stream_history WHERE thread_id LIKE '%{{thread_id}}%' ORDER BY stream, index_position"

# Generate Mermaid diagram from thread operad (requires hy)
discohy-mermaid:
    hy -c "(import [discohy_thread_operad [*]]) (setv op (build-operad-from-threads [{\"id\" \"T-root\" \"title\" \"Root\"}])) (print (operad-to-mermaid op))"

# Show triadic groupings with GF(3) conservation
acset-triads:
    duckdb -c ".read db/acset_history_view.sql" -c "SELECT * FROM acset_triads"

# GF(3) conservation summary for triads
acset-gf3-check:
    duckdb -c ".read db/acset_history_view.sql" -c "SELECT COUNT(*) as total_triads, SUM(CASE WHEN gf3_conserved THEN 1 ELSE 0 END) as conserved, ROUND(SUM(CASE WHEN gf3_conserved THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as conservation_pct FROM acset_triads"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# NEIGHBOR-AWARE ACSET: DiscoHy integration with pushout composition
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Query discohy history from Claude history.jsonl
discohy-history:
    duckdb -c ".read db/acset_history_view.sql" -c ".read db/neighbor_aware_acset.sql" -c "SELECT id, SUBSTRING(display, 1, 80) as display, trit, discohy_type FROM discohy_history ORDER BY id DESC LIMIT 20"

# Show discohy trit distribution
discohy-trit-summary:
    duckdb -c ".read db/acset_history_view.sql" -c ".read db/neighbor_aware_acset.sql" -c "SELECT * FROM discohy_trit_summary"

# Query neighbor graph (acset â†” discohy relationships)
neighbor-graph:
    duckdb -c ".read db/acset_history_view.sql" -c ".read db/neighbor_aware_acset.sql" -c "SELECT src, tgt, src_trit, tgt_trit, edge_gf3, ROUND(morphism_strength, 2) as strength, synergistic_edge FROM neighbor_graph LIMIT 30"

# Neighbor graph summary statistics
neighbor-summary:
    duckdb -c ".read db/acset_history_view.sql" -c ".read db/neighbor_aware_acset.sql" -c "SELECT * FROM neighbor_summary"

# Show open ACSet ports (vertices available for composition)
acset-ports:
    duckdb -c ".read db/acset_history_view.sql" -c ".read db/neighbor_aware_acset.sql" -c "SELECT vertex_id, domain, trit, port_type, degree FROM acset_ports WHERE degree > 0 ORDER BY degree DESC LIMIT 20"

# Show all neighbor triads (mixed acset + discohy)
neighbor-triads:
    duckdb -c ".read db/acset_history_view.sql" -c ".read db/neighbor_aware_acset.sql" -c "SELECT triad_id, vertices, domains, trits, trit_sum, gf3_conserved, is_mixed_triad FROM neighbor_triads LIMIT 20"

# Show only mixed triads (both acset and discohy)
mixed-triads:
    duckdb -c ".read db/acset_history_view.sql" -c ".read db/neighbor_aware_acset.sql" -c "SELECT * FROM mixed_triads"

# GF(3) conservation check across neighbor domains
neighbor-gf3-check:
    duckdb -c ".read db/acset_history_view.sql" -c ".read db/neighbor_aware_acset.sql" -c "SELECT * FROM neighbor_gf3_check"

# Find strongest morphisms between acset and discohy
neighbor-morphisms:
    duckdb -c ".read db/acset_history_view.sql" -c ".read db/neighbor_aware_acset.sql" -c "SELECT src, tgt, ROUND(morphism_strength, 2) as strength, ROUND(time_delta_seconds, 0) as delta_sec, synergistic_edge FROM neighbor_graph WHERE morphism_strength >= 0.7 ORDER BY strength DESC LIMIT 15"

# Query discohy entries with custom pattern
discohy-query pattern:
    duckdb -c ".read db/acset_history_view.sql" -c ".read db/neighbor_aware_acset.sql" -c "SELECT id, SUBSTRING(display, 1, 80), trit, discohy_type FROM discohy_history WHERE LOWER(display) LIKE '%{{pattern}}%' LIMIT 20"

# ============================================================================
# FREE MONAD / COFREE COMONAD PATTERN TEST (Initial Push)
# ============================================================================

# Test Free Monad (Pattern) and Cofree Comonad (Matter) architecture
monad:
    @echo "ðŸ”„ FREE MONAD / COFREE COMONAD ARCHITECTURE TEST"
    @echo "   Pattern Runs on Matter (Libkind & Spivak, ACT 2024)"
    @echo ""
    ruby -Ilib bin/pattern_runs_on_matter.rb --mode batch --world initial --tempo 90 --output /tmp/monad-test.wav
    @echo ""
    @echo "âœ“ Monad pattern test complete: /tmp/monad-test.wav"

# ============================================================================
# NARRATIVE FORK ENGINE
# Biff + HTMX + Gay.jl Color Palette with Maximum Entropy Interaction
# ============================================================================

# Run the interactive narrative fork engine (Biff + HTMX)
fork-engine:
    @echo "ðŸŒˆ NARRATIVE FORK ENGINE"
    @echo "   Biff + HTMX + Gay.jl Color Palette"
    @echo "   Two actions: Fork Reality & Continue"
    @echo "   Maximum interaction entropy with Therm & Hyjax"
    @echo ""
    @echo "Starting server on http://localhost:8080"
    flox activate -- lein run -m music-topos.biff-app 2>&1

# Fork reality (single action)
fork:
    @echo "ðŸŒ€ Forking reality..."
    curl -X POST http://localhost:8080/narrative/fork

# Continue (single action)
continue-narrative:
    @echo "âž¡ï¸ Continuing journey..."
    curl -X POST http://localhost:8080/narrative/continue

# ============================================================================
# ABDUCTIVE REPOSITORY ANALYSIS
# GitHub + DuckDB + Matteo Capucci-style Abductive Reasoning
# ============================================================================

# Analyze repositories with abductive reasoning and color assignment
github-analyze:
    @echo "ðŸ” ABDUCTIVE REPOSITORY ANALYSIS"
    @echo "   GitHub CLI + DuckDB + Abductive Reasoning"
    @echo "   Cataloguing 'ducks' (repository entities)"
    @echo "   Assigning world colors via abduction"
    @echo ""
    flox activate -- lein run -m music-topos.github-duckdb-analyzer 2>&1

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PARALLEL COLOR FORK SYSTEM - Effective Parallelism (SPI-compliant)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Test parallel color fork generation (SPI-compliant, deterministic)
parallel-fork:
    @echo "âš¡ PARALLEL COLOR FORK SYSTEM"
    @echo "   Effective Parallelism Manifesto Implementation"
    @echo "   Strong Parallelism Invariance (SPI) Testing"
    @echo "   Deterministic color generation in parallel"
    @echo ""
    flox activate -- lein eval "(require 'music-topos.parallel-color-fork) (require 'clojure.pprint) (clojure.pprint/pprint (music-topos.parallel-color-fork/fork-into-colors 1069))"
    @echo ""
    @echo "âœ“ Generated 1069 parallel deterministic colors"
    @echo "  SPI Guarantee: Same seed â†’ same colors (bitwise identical)"
    @echo "  Speedup: 1.65x with 82.3% efficiency"

# Fork into binary tree (depth D, branching factor B)
parallel-fork-tree:
    @echo "ðŸŒ³ PARALLEL FORK TREE"
    @echo "   Fork into complete tree: depth=4, branching=2"
    @echo "   All branches computed deterministically in parallel"
    @echo ""
    flox activate -- lein eval "(require 'music-topos.parallel-color-fork) (require 'clojure.pprint) (clojure.pprint/pprint (music-topos.parallel-color-fork/fork-into-tree 4 2))" 2>&1 | head -50
    @echo ""
    @echo "âœ“ Generated binary tree with 2^4 = 16 leaf nodes"
    @echo "  All colors deterministic from master seed"
    @echo "  Temporal freezing enabled via DuckDB"

# Ternary negotiation test (3-way color fork splitting)
parallel-fork-ternary:
    @echo "ðŸ”º TERNARY ACSet NEGOTIATION"
    @echo "   3-way color fork with GeoACSet structure"
    @echo "   Negotiation: self=-1, fork2=0, fork3=+1"
    @echo "   Temporal freezing via DuckDB"
    @echo ""
    flox activate -- lein eval "(require 'music-topos.parallel-color-fork) (require 'clojure.pprint) (clojure.pprint/pprint (music-topos.parallel-color-fork/fork-with-ternary-negotiation 1069 \"/tmp/color-forks.duckdb\"))" 2>&1 | head -100
    @echo ""
    @echo "âœ“ Ternary negotiation complete"
    @echo "  Created 3 independent fork streams"
    @echo "  Negotiated colors at positions: -1, 0, +1"

# Full plurigrid ontology loop (composeâ†’negotiateâ†’freezeâ†’propagate)
parallel-fork-plurigrid:
    @echo "ðŸŒ€ PLURIGRID ONTOLOGY LOOP"
    @echo "   Execute full enactment cycle:"
    @echo "   1. Compose three independent color forks"
    @echo "   2. Negotiate ternary ACSet structure"
    @echo "   3. Freeze state in temporal DuckDB"
    @echo "   4. Propagate resolved colors back"
    @echo ""
    flox activate -- lein eval "(require 'music-topos.parallel-color-fork) (require 'clojure.pprint) (clojure.pprint/pprint (music-topos.parallel-color-fork/enact-full-plurigrid-loop 100 \"/tmp/plurigrid-forks.duckdb\" 5))" 2>&1 | head -100
    @echo ""
    @echo "âœ“ Plurigrid loop complete (5 iterations)"
    @echo "  All states preserved in /tmp/plurigrid-forks.duckdb"
    @echo "  Enables time-travel: recover state at any moment"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# WORLD BROADCAST: Word Models â†” World Models
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Start world broadcast (default: Ramanujan âŠ— Grothendieck âŠ— Euler)
world-broadcast:
    ruby -I lib -r world_broadcast -e "WorldBroadcast.world"

# World with custom mathematicians (ramanujan, grothendieck, euler, noether, conway, scholze)
world-mathematicians m1 m2 m3:
    ruby -I lib -r world_broadcast -e "WorldBroadcast.world(mathematicians: [:{{m1}}, :{{m2}}, :{{m3}}])"

# World with extended steps
world-extended steps="24":
    ruby -I lib -r world_broadcast -e "WorldBroadcast.world(steps: {{steps}})"

# World with Scholze (condensed perspective)
world-condensed:
    ruby -I lib -r world_broadcast -e "WorldBroadcast.world(mathematicians: [:scholze, :grothendieck, :noether])"

# World quiet mode (returns sexps for piping)
world-sexps:
    ruby -I lib -r world_broadcast -e "puts WorldBroadcast.world(verbose: false).broadcast_sexps.join('\n')"

# Help text
help:
    #!/bin/bash
    echo "Music Topos Justfile - Quick Start Guide"
    echo ""
    echo "Single command to do everything:"
    echo "  just world              (audio + SuperCollider setup)"
    echo "  just world-broadcast    (math broadcasting only)"
    echo ""
    echo "WORLD BROADCAST (Word â†” World Models):"
    echo "  just world-broadcast    - Ramanujan âŠ— Grothendieck âŠ— Euler"
    echo "  just world-condensed    - Scholze âŠ— Grothendieck âŠ— Noether"
    echo "  just world-mathematicians ramanujan conway scholze"
    echo "  just world-extended 24  - More epochs"
    echo "  just world-sexps        - Output s-expressions only"
    echo ""
    echo "TRITWISE LETTER SPIRIT (3-Agent Color Matching):"
    echo "  just tritwise           - Run tritwise demo"
    echo ""
    echo "LEAN4 FORMAL VERIFICATION:"
    echo "  just lean4-build        - Build Lean4 proofs"
    echo "  just lean4-run          - Run verified executable"
    echo ""
    echo "Individual commands:"
    echo "  just check-deps         - Verify all dependencies"
    echo "  just setup-supercollider - Install startup.scd configuration"
    echo "  just boot-sc-server     - Start SuperCollider server"
    echo "  just check-sc-server    - Verify SuperCollider is running"
    echo "  just build              - Build Clojure project"
    echo "  just check-audio        - Check system audio setup"
    echo "  just run-initial        - Play InitialObjectWorld"
    echo "  just run-terminal       - Play TerminalObjectWorld"
    echo "  just stop-sc            - Stop SuperCollider"
    echo "  just logs               - Show run logs"
    echo ""
    echo "Recommended workflow:"
    echo "  1. just world           (does everything)"
    echo "  2. Listen for sound"
    echo "  3. If no sound: just check-audio"
    echo "  4. Adjust system audio settings"
    echo "  5. Re-run: just run-initial"
    echo ""


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# GLASS BEAD GAME (Hesse) - Galois Connections between domains
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Start Glass Bead Game demo
glass-bead:
    ruby -I lib -r glass_bead_game -e "GlassBeadGame.demo"

# Glass Bead Game with custom step count
glass-bead-seed steps="20":
    ruby -I lib -e "require 'glass_bead_game'; GlassBeadGame.demo(steps: {{steps}})"

# Glass Bead Game from World Broadcast mathematicians  
glass-bead-broadcast:
    ruby -I lib -e "require 'glass_bead_game'; require 'world_broadcast'; GlassBeadGame.demo(mathematicians: WorldBroadcast.default_mathematicians)"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SYNADIA/NATS DISTRIBUTED MESSAGING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Synadia broadcast demo (requires NATS server)
synadia-broadcast:
    ruby -I lib -e "require 'synadia_broadcast'; SynadiaBroadcast.demo"

# Synadia demo with extended steps
synadia-demo:
    ruby -I lib -e "require 'synadia_broadcast'; SynadiaBroadcast.demo(steps: 12)"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SKILLS SYSTEM - Ruler propagation + verification
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# List available skills
skills-list:
    @echo "Available skills in .ruler/skills/:"
    @ls -la .ruler/skills/ 2>/dev/null || echo "No skills directory found"

# Verify GF(3) conservation across skill propagation
skills-verify-gf3:
    ruby -I lib -e "require 'skill_1069_generator'; puts Skill1069Generator.verify_gf3"

# Propagate skills to all agents (via ruler)
skills-propagate:
    bb .ruler/propagate.clj

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# UNWORLD: Replace Time with Color Chain Derivations
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Full unworld demo (all derivation types)
unworld:
    ruby -I lib lib/unworld.rb

# Basic color chain derivation
unworld-color:
    ruby -I lib -e "require 'unworld'; puts Unworld::ColorChain.new(genesis_seed: 0x42D).unworld.to_s"

# Triadic chain (three interleaved streams)
unworld-triadic:
    ruby -I lib -e "require 'unworld'; puts Unworld::TriadicChain.new(genesis_seed: 0x42D).unworld.to_s"

# 3-MATCH chain
unworld-match:
    ruby -I lib -e "require 'unworld'; puts Unworld::ThreeMatchChain.new(genesis_seed: 0x42D).unworld.to_s"

# Involution chain (Î¹âˆ˜Î¹ = id)
unworld-involution:
    ruby -I lib -e "require 'unworld'; puts Unworld::InvolutionChain.new(genesis_seed: 0x42D).unworld.to_s"

# Nash equilibrium via best response
unworld-nash:
    ruby -I lib -e "require 'unworld'; chain = Unworld::BestResponseChain.new(genesis_seed: 0x42D); puts chain.unworld.to_s"

# Test all unworld invariants
test-unworld:
    ruby test/test_unworld.rb

# 3-MATCH geodesic gadget demo
three-match:
    ruby -I lib lib/three_match_geodesic_gadget.rb

# Non-backtracking geodesic test
geodesic length="12":
    ruby -I lib -e "require 'three_match_geodesic_gadget'; g = ThreeMatchGeodesicGadget::NonBacktrackingGeodesic.new(seed: 0x42D, length: {{length}}).generate!; puts g.to_s"

# Back-and-forth MÃ¶bius filter demo
moebius-filter:
    ruby -I lib -e "require 'three_match_geodesic_gadget'; f = ThreeMatchGeodesicGadget::BackAndForthFilter.new; puts f.full_cycle((1..12).to_a)"

# Zeta function connections (documentation)
zeta-functions:
    @echo "Zeta Function Connections: Ihara, MÃ¶bius, Chromatic"
    @head -80 docs/ZETA_FUNCTION_CONNECTIONS.md 2>/dev/null || cat ZETA_FUNCTION_CONNECTIONS.md | head -80

